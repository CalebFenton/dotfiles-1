#!/usr/bin/env ruby
require "optparse"
require "time"

# TODO: Rename remote_tmp_snapshot_path to dest_tmp_snapshot_path
class BtrfsBk
  # In Minutes.
  RESUME_CUTOFF = 5
  WOL_TIMEOUT = 1

  class Error < StandardError; end
  class CommandError < StandardError; end

  def initialize(options)
    @options = defaults
      .merge(options)
      .merge(parse_dest_path(options[:dest]))

    @remote_host_originally_down = false

    # if @options[:remote_host]
    #   @options.merge!(parse_remote_host_options(@options[:remote_host]))
    # end

  # Record at initialise if the system was recently resumed.
  # This allows us to suspend the system after, as the script was most likely
  # ran as part of a wakeup script and not actually being actively used.
#   def get_latest_system_resume_time
#     journal = `journalctl -b 0 -o short-iso MESSAGE="PM: Finishing wakeup."`
#     date_str = journal.split("\n").last.split(" ").first
#     begin
#       date = Time.parse(date_str)
#     rescue ArgumentError
#       date = nil
#     end
#   end
  # def record_resume_status!
  #   resumed_at = get_latest_system_resume_time
  #   if resumed_at && resumed_at >= (Time.now - (RESUME_CUTOFF * 60))
  #     @recently_resumed = true
  #   else
  #     @recently_resumed = false
  #   end
  # end
  end

  def run!
    if remote_dest? && !remote_host_up?
      wakeup_remote_host!
    end

    begin
      create_local_tmp_snapshot!
      send_backup!
      finalize_backup!
    ensure
      cleanup!
    end

    # Shutdown remote system?
    # Shutdown local system?
  end

  def defaults
    {dry_run: false,
     auto_suspend: false,
     progress: false,
     wol: false}
  end

  private
  def snapshot_name
    "btrfs-bk__#{@options[:name]}"
  end

  def snapshot_tmp_name
    "btrfs-bk__#{@options[:name]}-tmp"
  end

  def remote_tmp_snapshot_path
    File.join(@options[:dest_path], snapshot_tmp_name)
  end

  def local_tmp_snapshot_path
    File.join(@options[:local_dest], snapshot_tmp_name)
  end

  def local_snapshot_path
    File.join(@options[:local_dest], snapshot_name)
  end

  def remote_snapshot_path
    File.join(@options[:dest_path], snapshot_name)
  end

  def dest_path
    @options[:dest_path]
  end

  def suspend_remote_system?
    @remote_host_originally_down == true
  end

  def suspend_this_system?
  end

  def wakeup_remote_host!
    success = false
    if @options[:wol]
      @remote_host_originally_down = true
      success = run_wol_and_wait
    end

    if !success
      raise Error, "Unable to find remote host: #{remote_hostname}. Are you sure its up?"
    end
  end

  def run_wol_and_wait
    start = Time.now
    if !run_cmd("wol", @options[:wol])
      raise "Failed wake on lan. Is wol package installed?"
    end

    success = false
    while !success
      if (start + (WOL_TIMEOUT * 60)) < Time.now
        return false
      end
      success = remote_host_up?
      sleep 5
    end
    success
  end

  def cleanup!
    if File.exists?(local_tmp_snapshot_path)
      run_cmd(btrfs_binary, "subvol", "delete", local_tmp_snapshot_path)
    end

    if remote_dest? && remote_cmd("test -e", remote_tmp_snapshot_path)
      remote_cmd("sudo", btrfs_binary, "subvol", "del", remote_tmp_snapshot_path)
    elsif File.exists?(remote_tmp_snapshot_path)
      run_cmd(btrfs_binary, "subvol", "del", remote_tmp_snapshot_path)
    end
  end

  def create_local_tmp_snapshot!
    if File.exists?(local_tmp_snapshot_path)
      raise Error, "Local snapshot already exists! Previous job didn't clean up correctly?"
    end
    run_cmd(btrfs_binary, "subvol", "snapshot", "-r", @options[:src], local_tmp_snapshot_path)
  end

  def finalize_backup!
    if remote_file_exists?(remote_snapshot_path)
      remote_cmd("sudo", btrfs_binary, "subvol", "del", remote_snapshot_path)
    end
    remote_cmd("sudo", "mv", remote_tmp_snapshot_path, remote_snapshot_path)

    if File.exists?(local_snapshot_path)
      run_cmd(btrfs_binary, "subvol", "del", local_snapshot_path)
    end
    run_cmd("mv", local_tmp_snapshot_path, local_snapshot_path)
  end

  def remote_file_exists?(path)
    remote_cmd("test -e", path)
  end

  def get_diff_size
    size = 0
    output = run_cmd(btrfs_binary, "subvol", "show", local_snapshot_path)
    if output =~ /Generation[^:]*:\s+(\d+)/
      gen = Integer($1)
      size = get_size(gen)
    end

    size
  end

  def get_size(gen=0)
    size = 0
    run_cmd(btrfs_binary, "subvol", "find-new", local_tmp_snapshot_path, gen.to_s) do |io|
      while !io.eof?
        if io.gets =~ /len (\d+)/
          size = size + Integer($1)
        end
      end
    end
    size
  end

  def send_backup!
    # Main snapshot exists locally, we can send incremental backup.
    if File.exists?(local_snapshot_path)
      opts = ["-p", local_snapshot_path]
      estimated_size = get_diff_size
    else
      opts = []
      estimated_size = get_size(0)
    end

    if remote_dest?
      receive_cmd = [ssh_binary, @options[:remote_host].to_s, "sudo", btrfs_binary, "receive"]
    else
      receive_cmd = [btrfs_binary, "receive"]
    end

    popen(btrfs_binary, "send", *opts, local_tmp_snapshot_path) do |send_io|
      popen(*receive_cmd, dest_path, mode: "w", out: "/dev/null") do |receive_io|
        receive_io.sync = true
        copy_stream(send_io, receive_io, estimated_size: estimated_size)
      end
    end
  end

  def remote_dest?
    !@options[:remote_host].nil?
  end

  def remote_host_up?
    run_cmd("/usr/bin/ping", "-c 1 -W 5", remote_hostname)
  end

  def remote_hostname
    @options[:remote_host].to_s.split("@").last
  end

  def parse_dest_path(dest)
    if dest.to_s =~ /:/
      dest_split = dest.split(":")
      {dest_path: dest_split.last,
       remote_host: dest_split.first}
    else
      {dest_path: dest,
       remote_host: nil}
    end
  end

  def run_cmd(*args, &blk)
    blk ||= -> (io) { io.read }
    popen(*args, &blk)
  rescue CommandError
    false
  end

  def remote_cmd(*args, **options, &blk)
    run_cmd(*[ssh_binary, @options[:remote_host].to_s, *args], **options, &blk)
  end

  def btrfs_binary
    "/usr/bin/btrfs"
  end

  def ssh_binary
    "/usr/bin/ssh"
  end

  # Low level popen that attempts to handle errors.
  def popen(*args, mode: "r", **options)
    err_r, err_w = IO.pipe
    result = nil

    puts "Running: #{args.join(" ")}"
    IO.popen([*args, err: err_w, **options], mode) do |io|
      err_w.close
      result = yield(io)
    end

    if $?.success?
      result
    else
      raise CommandError, err_r.read
    end
  end

  def copy_stream(send_io, receive_io, chunk_length: (1 << 20), estimated_size: 0)
    longest_message_length = 0
    start = Time.now
    counter = 0
    while !send_io.eof?
      if buffer = send_io.read(chunk_length)
        receive_io.write(buffer)

        counter += buffer.size
        rate = counter / (Time.now - start)

        remaining =
          if estimated_size > counter
            human_readable_time((estimated_size - counter) / rate)
          elsif counter - estimated_size < 100 * 1024**2
            human_readable_time(0)
          else
            '?'
          end

        msg = "#{human_readable_size(counter)}/#{human_readable_size(estimated_size)} (#{human_readable_size(rate)}/s), #{remaining} remaining"
        longest_message_length = [longest_message_length, msg.length].max
        print "\r%-#{longest_message_length}s" % [msg]
      end
    end
    print "\r#{" " * longest_message_length}\r"
    counter
  rescue Interrupt => e
    print "\r\n\r"
    raise e
  end

  def human_readable_time(time)
    hrs = time / 3600
    min = (time / 60) % 60
    sec = time % 60
    "%02i:%02i:%02i" % [hrs, min, sec]
  end

  def human_readable_size(size, digits: 1)
    order = ['B', 'kB', 'MB', 'GB']
    magnitude =
      if size > 0
        Integer(Math.log2(size) / 10)
      else 0
      end
    "%.#{digits}f#{order[magnitude]}" % [Float(size) / (1024 ** magnitude)]
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = "btrfs-bk.rb --dest user@host:/mnt/backups/server --name root SRC"

  opts.on("-n", "--name NAME", "Name of snapshot on DEST") do |v|
    options[:name] = v
  end

  opts.on("-l", "--local-dest DEST", "Place to store local snapshots for incrementals") do |v|
    options[:local_dest] = v
  end

  opts.on("-d", "--dest DEST", "Destination btrfs location for snapshots") do |v|
    options[:dest] = v
  end

  opts.on("-w", "--wol MAC", "Wake on LAN remote host if currently down") do |v|
    options[:wol] = v
  end

  opts.on("-p", "--progress", "Show progress bar") do |v|
    options[:progress] = v
  end

  opts.on("--dry-run", "Don't actually do anything, just print commands") do |v|
    options[:dry_run] = v
  end

  opts.on("--auto-suspend", "Suspend system after a recent wakeup") do |v|
    options[:auto_suspend] = v
  end
end.parse!(ARGV)
options[:src] = [*ARGV.unshift].first

BtrfsBk.new(options).run!
